//! Sumcheck Protocol for multilinear extension

pub mod data_structures;
pub mod protocol;

use ark_ff::Field;
use ark_serialize::CanonicalSerialize;
use ark_std::marker::PhantomData;
use ark_std::vec::Vec;
use data_structures::{ListOfProductsOfPolynomials, PolynomialInfo};
use protocol::prover::{ProverMsg, ProverState};
use protocol::verifier::SubClaim;
use protocol::IPForMLSumcheck;

// Error type for the ml_sumcheck crate
#[derive(Debug)]
pub enum Error {
    Reject(Option<String>),
    OtherError(String),
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::Reject(Some(msg)) => write!(f, "Reject: {}", msg),
            Error::Reject(None) => write!(f, "Reject"),
            Error::OtherError(msg) => write!(f, "OtherError: {}", msg),
        }
    }
}

impl std::error::Error for Error {}

// RNG trait
pub trait FeedableRNG {
    type Error;
    fn feed(&mut self, data: &[u8]) -> Result<(), Self::Error>;
}

// Mock Blake2b512Rng for now
pub struct Blake2b512Rng {
    // Simple mock implementation
    bytes: Vec<u8>,
}

impl Blake2b512Rng {
    pub fn setup() -> Self {
        Self { bytes: Vec::new() }
    }
}

impl FeedableRNG for Blake2b512Rng {
    type Error = Error;
    fn feed(&mut self, data: &[u8]) -> Result<(), Self::Error> {
        self.bytes.extend_from_slice(data);
        Ok(())
    }
}

impl ark_std::rand::RngCore for Blake2b512Rng {
    fn next_u32(&mut self) -> u32 {
        // Simple mock implementation
        if self.bytes.len() >= 4 {
            let mut bytes = [0u8; 4];
            bytes.copy_from_slice(&self.bytes[..4]);
            self.bytes.drain(..4);
            u32::from_le_bytes(bytes)
        } else {
            0
        }
    }

    fn next_u64(&mut self) -> u64 {
        if self.bytes.len() >= 8 {
            let mut bytes = [0u8; 8];
            bytes.copy_from_slice(&self.bytes[..8]);
            self.bytes.drain(..8);
            u64::from_le_bytes(bytes)
        } else {
            0
        }
    }

    fn fill_bytes(&mut self, dest: &mut [u8]) {
        for byte in dest.iter_mut() {
            *byte = self.next_u32() as u8;
        }
    }

    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), ark_std::rand::Error> {
        self.fill_bytes(dest);
        Ok(())
    }
}
#[cfg(test)]
mod test;

/// Sumcheck for products of multilinear polynomial
pub struct MLSumcheck<F: Field>(#[doc(hidden)] PhantomData<F>);

/// proof generated by prover
pub type Proof<F> = Vec<ProverMsg<F>>;

impl<F: Field> MLSumcheck<F> {
    /// extract sum from the proof
    pub fn extract_sum(proof: &Proof<F>) -> F {
        proof[0].evaluations[0] + proof[0].evaluations[1]
    }

    /// generate proof of the sum of polynomial over {0,1}^`num_vars`
    ///
    /// The polynomial is represented by a list of products of polynomials along with its coefficient that is meant to be added together.
    ///
    /// This data structure of the polynomial is a list of list of `(coefficient, DenseMultilinearExtension)`.
    /// * Number of products n = `polynomial.products.len()`,
    /// * Number of multiplicands of ith product m_i = `polynomial.products[i].1.len()`,
    /// * Coefficient of ith product c_i = `polynomial.products[i].0`
    ///
    /// The resulting polynomial is
    ///
    /// $$\sum_{i=0}^{n}C_i\cdot\prod_{j=0}^{m_i}P_{ij}$$
    pub fn prove(polynomial: &ListOfProductsOfPolynomials<F>) -> Result<Proof<F>, Error> {
        let mut fs_rng = Blake2b512Rng::setup();
        Self::prove_as_subprotocol(&mut fs_rng, polynomial).map(|r| r.0)
    }

    /// This function does the same thing as `prove`, but it uses a `FeedableRNG` as the transcript/to generate the
    /// verifier challenges. Additionally, it returns the prover's state in addition to the proof.
    /// Both of these allow this sumcheck to be better used as a part of a larger protocol.
    pub fn prove_as_subprotocol(
        fs_rng: &mut (impl FeedableRNG<Error = Error> + ark_std::rand::RngCore),
        polynomial: &ListOfProductsOfPolynomials<F>,
    ) -> Result<(Proof<F>, ProverState<F>), Error> {
        fs_rng.feed(&polynomial.info().to_bytes())?;

        let mut prover_state = IPForMLSumcheck::prover_init(polynomial);
        let mut verifier_msg = None;
        let mut prover_msgs = Vec::with_capacity(polynomial.num_variables);
        for _ in 0..polynomial.num_variables {
            let prover_msg = IPForMLSumcheck::prove_round(&mut prover_state, &verifier_msg);
            {
                let mut bytes = Vec::new();
                prover_msg.serialize_uncompressed(&mut bytes).unwrap();
                fs_rng.feed(&bytes)?;
            }
            prover_msgs.push(prover_msg);
            verifier_msg = Some(IPForMLSumcheck::sample_round(fs_rng));
        }
        prover_state
            .randomness
            .push(verifier_msg.unwrap().randomness);

        Ok((prover_msgs, prover_state))
    }

    /// verify the claimed sum using the proof
    pub fn verify(
        polynomial_info: &PolynomialInfo,
        claimed_sum: F,
        proof: &Proof<F>,
    ) -> Result<SubClaim<F>, Error> {
        let mut fs_rng = Blake2b512Rng::setup();
        Self::verify_as_subprotocol(&mut fs_rng, polynomial_info, claimed_sum, proof)
    }

    /// This function does the same thing as `prove`, but it uses a `FeedableRNG` as the transcript/to generate the
    /// verifier challenges. This allows this sumcheck to be used as a part of a larger protocol.
    pub fn verify_as_subprotocol(
        fs_rng: &mut (impl FeedableRNG<Error = Error> + ark_std::rand::RngCore),
        polynomial_info: &PolynomialInfo,
        claimed_sum: F,
        proof: &Proof<F>,
    ) -> Result<SubClaim<F>, Error> {
        fs_rng.feed(&polynomial_info.to_bytes())?;
        let mut verifier_state = IPForMLSumcheck::verifier_init(polynomial_info);
        for i in 0..polynomial_info.num_variables {
            let prover_msg = proof.get(i).expect("proof is incomplete");
            {
                let mut bytes = Vec::new();
                prover_msg.serialize_uncompressed(&mut bytes).unwrap();
                fs_rng.feed(&bytes)?;
            }
            let _verifier_msg =
                IPForMLSumcheck::verify_round((*prover_msg).clone(), &mut verifier_state, fs_rng);
        }

        IPForMLSumcheck::check_and_generate_subclaim(verifier_state, claimed_sum)
    }
}
